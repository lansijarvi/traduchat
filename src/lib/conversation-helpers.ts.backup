import { 
  deleteDoc, 
  collection, 
  addDoc, 
  query, 
  where, 
  orderBy, 
  onSnapshot, 
  serverTimestamp,
  doc,
  setDoc,
  getDoc,
  updateDoc,
} from 'firebase/firestore';
import type { Firestore } from 'firebase/firestore';
import { translateMessage } from "@/ai/flows/real-time-translation";

export interface ConversationData {
  id: string;
  participants: string[];
  participantDetails: Record<string, {
    username: string;
    displayName: string;
    avatarUrl: string | null;
    language: 'en' | 'es';
  }>;
  lastMessage: string;
  lastMessageTimestamp: Date;
  unreadCount?: Record<string, number>;
}

export interface MediaAttachment {
  type: 'image' | 'video' | 'file';
  url: string;
  name: string;
  size?: number;
  thumbnail?: string;
}

export interface LinkPreview {
  url: string;
  title: string;
  description: string;
  image: string | null;
}

export interface MessageData {
  id: string;
  text: string;
  translatedText?: string;
  senderId: string;
  senderLanguage: 'en' | 'es';
  timestamp: Date;
  read: boolean;
  media?: MediaAttachment[];
  linkPreview?: LinkPreview;
}

export async function getConversationById(db: Firestore, conversationId: string) {
  const conversationSnap = await getDoc(doc(db, 'conversations', conversationId));
  if (!conversationSnap.exists()) return null;
  return { id: conversationSnap.id, ...conversationSnap.data() };
}

export async function getUserConversations(db: Firestore, userId: string): Promise<ConversationData[]> {
  const q = query(
    collection(db, 'conversations'),
    where('participants', 'array-contains', userId),
    orderBy('lastMessageTimestamp', 'desc')
  );

  return new Promise((resolve, reject) => {
    const unsubscribe = onSnapshot(q, (snapshot) => {
      const conversations = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        lastMessageTimestamp: doc.data().lastMessageTimestamp?.toDate() || new Date(),
      } as ConversationData));
      unsubscribe();
      resolve(conversations);
    }, reject);
  });
}

async function getTranslation(
  text: string,
  senderLanguage: 'en' | 'es',
  receiverId: string,
  db: Firestore
): Promise<string | undefined> {
  const receiverSnap = await getDoc(doc(db, 'users', receiverId));
  const receiverLanguage = receiverSnap.exists() ? (receiverSnap.data().language || 'en') : 'en';
  
  if (senderLanguage === receiverLanguage) return undefined;
  
  try {
    const result = await translateMessage({
      text,
      sourceLanguage: senderLanguage,
      targetLanguage: receiverLanguage,
    });
    return result.translatedText;
  } catch (error) {
    console.error('Translation failed:', error);
    return undefined;
  }
}

export async function sendMessage(
  db: Firestore,
  conversationId: string,
  senderId: string,
  text: string,
  senderLanguage: 'en' | 'es',
  media?: MediaAttachment[],
  linkPreview?: LinkPreview
): Promise<void> {
  const conversationSnap = await getDoc(doc(db, 'conversations', conversationId));
  if (!conversationSnap.exists()) throw new Error('Conversation not found');
  
  const conversation = conversationSnap.data();
  const receiverId = conversation.participants?.find((id: string) => id !== senderId);
  
  const translatedText = receiverId && text 
    ? await getTranslation(text, senderLanguage, receiverId, db)
    : undefined;

  const messageData: any = {
    text,
    senderId,
    senderLanguage,
    timestamp: serverTimestamp(),
    read: false,
  };

  if (translatedText) messageData.translatedText = translatedText;
  if (media?.length) messageData.media = media;
  if (linkPreview) messageData.linkPreview = linkPreview;
  
  await addDoc(collection(db, 'conversations', conversationId, 'messages'), messageData);
  
  const lastMessage = text || (media?.length ? 'ðŸ“Ž Attachment' : 'ðŸ”— Link');
  const updateData: any = {
    lastMessage,
    lastMessageTimestamp: serverTimestamp(),
    updatedAt: serverTimestamp(),
  };
  
  if (receiverId) {
    updateData[`unreadCount.${receiverId}`] = (conversation.unreadCount?.[receiverId] || 0) + 1;
  }
  
  await setDoc(doc(db, 'conversations', conversationId), updateData, { merge: true });
}

export async function createConversation(
  db: Firestore,
  participant1Id: string,
  participant2Id: string,
  participant1Details: { username: string; displayName: string; avatarUrl?: string; language?: 'en' | 'es' },
  participant2Details: { username: string; displayName: string; avatarUrl?: string; language?: 'en' | 'es' }
): Promise<string> {
  const conversationId = [participant1Id, participant2Id].sort().join('_');

  await setDoc(doc(db, 'conversations', conversationId), {
    participants: [participant1Id, participant2Id],
    participantDetails: {
      [participant1Id]: {
        username: participant1Details.username,
        displayName: participant1Details.displayName,
        avatarUrl: participant1Details.avatarUrl || null,
        language: participant1Details.language || 'en',
      },
      [participant2Id]: {
        username: participant2Details.username,
        displayName: participant2Details.displayName,
        avatarUrl: participant2Details.avatarUrl || null,
        language: participant2Details.language || 'en',
      },
    },
    lastMessage: '',
    lastMessageTimestamp: serverTimestamp(),
    createdAt: serverTimestamp(),
    updatedAt: serverTimestamp(),
  }, { merge: true });

  return conversationId;
}

export async function acceptFriendRequest(db: Firestore, friendshipId: string, currentUserId: string): Promise<string> {
  const friendshipSnap = await getDoc(doc(db, 'friendships', friendshipId));
  if (!friendshipSnap.exists()) throw new Error('Friendship not found');

  const friendship = friendshipSnap.data();
  if (friendship.toUserId !== currentUserId) throw new Error('Not authorized to accept this request.');

  await updateDoc(doc(db, 'friendships', friendshipId), {
    status: 'accepted',
    acceptedAt: serverTimestamp(),
  });

  const [fromUserDoc, toUserDoc] = await Promise.all([
    getDoc(doc(db, 'users', friendship.fromUserId)),
    getDoc(doc(db, 'users', friendship.toUserId)),
  ]);

  if (!fromUserDoc.exists() || !toUserDoc.exists()) throw new Error('User not found');

  const fromUserData = fromUserDoc.data();
  const toUserData = toUserDoc.data();

  return createConversation(
    db,
    friendship.fromUserId,
    friendship.toUserId,
    {
      username: fromUserData.username,
      displayName: fromUserData.displayName,
      avatarUrl: fromUserData.avatarUrl,
      language: fromUserData.language
    },
    {
      username: toUserData.username,
      displayName: toUserData.displayName,
      avatarUrl: toUserData.avatarUrl,
      language: toUserData.language
    }
  );
}

export async function deleteMessage(
  db: Firestore,
  conversationId: string,
  messageId: string
): Promise<void> {
  await deleteDoc(doc(db, 'conversations', conversationId, 'messages', messageId));
}

export async function editMessage(
  db: Firestore,
  conversationId: string,
  messageId: string,
  newText: string,
  senderLanguage: 'en' | 'es'
): Promise<void> {
  const conversationSnap = await getDoc(doc(db, 'conversations', conversationId));
  if (!conversationSnap.exists()) throw new Error('Conversation not found');

  const messageSnap = await getDoc(doc(db, 'conversations', conversationId, 'messages', messageId));
  if (!messageSnap.exists()) throw new Error('Message not found');

  const conversation = conversationSnap.data();
  const messageData = messageSnap.data();
  const receiverId = conversation.participants?.find((id: string) => id !== messageData.senderId);
  
  const translatedText = receiverId && newText
    ? await getTranslation(newText, senderLanguage, receiverId, db)
    : undefined;

  const updateData: any = {
    text: newText,
    edited: true,
    editedAt: serverTimestamp(),
  };

  if (translatedText) updateData.translatedText = translatedText;

  await updateDoc(doc(db, 'conversations', conversationId, 'messages', messageId), updateData);
}